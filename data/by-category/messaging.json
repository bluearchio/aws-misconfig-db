{
  "category": "messaging",
  "count": 1,
  "misconfigurations": [
    {
      "id": "d4e5f6a7-b8c9-4012-d345-6789abcdef01",
      "status": "open",
      "service_name": "lambda",
      "scenario": "Lambda functions processing variable workload spikes synchronously without message queue buffering",
      "alert_criteria": "Lambda throttling errors >100/hour, API Gateway 5xx errors during traffic spikes, or direct synchronous invocation of compute-intensive functions",
      "recommendation_action": "Implement Queue-Based Load Leveling: 1) Place SQS queue between API Gateway and Lambda, 2) Configure API Gateway to send messages to SQS, 3) Set Lambda as SQS consumer with batch size 10-100, 4) Configure DLQ for failed messages, 5) Monitor queue depth",
      "risk_detail": "reliability, performance, cost",
      "build_priority": 1,
      "action_value": 3,
      "effort_level": 2,
      "risk_value": 2,
      "recommendation_description_detailed": "Synchronous processing fails during traffic spikes (10x spike = 90% failures). Queue-Based Load Leveling decouples request acceptance from processing: API Gateway succeeds immediately (200 OK after SQS write), Lambda processes at sustainable rate. Benefits: 1) No lost requests during spikes, 2) Consistent processing rate, 3) Auto-scaling based on queue depth. Example: E-commerce flash sale - 10K requests/sec spike vs 1K/sec capacity. Without queue: 9K failures. With SQS: all accepted, processed within SLA. Cost: SQS = $0.40 per million requests.",
      "category": "messaging",
      "architectural_patterns": [
        {
          "pattern_name": "Queue-Based Load Leveling",
          "relationship": "missing_implementation",
          "description": "Direct synchronous processing without queue buffer for variable workloads"
        }
      ],
      "pattern_implementation_guidance": "Create SQS queue (Standard for throughput, FIFO for ordering), create DLQ, update API Gateway integration to SQS (Action=SendMessage), create Lambda trigger from SQS with BatchSize=10, set Lambda reserved concurrency to control rate, configure CloudWatch alarms: ApproximateAgeOfOldestMessage >300s.",
      "output_notes": null,
      "notes": "AWS Architecture - Queue-Based Load Leveling Pattern",
      "references": [
        "https://docs.aws.amazon.com/lambda/latest/dg/with-sqs.html",
        "https://aws.amazon.com/blogs/compute/understanding-how-aws-lambda-scales-with-amazon-sqs-standard-queues/",
        "https://docs.aws.amazon.com/apigateway/latest/developerguide/integrating-api-with-aws-services-sqs.html"
      ],
      "metadata": {
        "created_at": "2025-11-06T20:44:23.794745+00:00",
        "updated_at": "2025-11-06T20:44:23.794745+00:00",
        "contributors": [
          "pattern-integration-2025"
        ],
        "source": "AWS Architecture - Queue-Based Load Leveling Pattern"
      },
      "tags": [
        "pattern:queue-load-leveling",
        "resilience-pattern",
        "sqs",
        "traffic-spike-handling",
        "decoupling"
      ]
    }
  ]
}