{
  "category": "database",
  "count": 1,
  "misconfigurations": [
    {
      "id": "b2c3d4e5-f6a7-4890-b123-456789abcdef",
      "status": "open",
      "service_name": "rds",
      "scenario": "Database queries repeated without caching layer implementation",
      "alert_criteria": "RDS DatabaseConnections >80% of max, identical SELECT queries >1000/min, or query response time >100ms for cacheable data",
      "recommendation_action": "Implement Cache-Aside pattern: 1) Deploy ElastiCache Redis/Memcached cluster, 2) Modify application to check cache before database, 3) Set appropriate TTL (5min for product catalog, 1hr for reference data), 4) Monitor cache hit rate (target >80%)",
      "risk_detail": "performance, cost, reliability",
      "build_priority": 1,
      "action_value": 3,
      "effort_level": 2,
      "risk_value": 2,
      "recommendation_description_detailed": "Cache-Aside pattern reduces database load by 70-95% for read-heavy workloads. Application checks cache first; on miss, queries database and populates cache. Without caching: 10,000 reads/sec on RDS = $500/month + performance degradation. With ElastiCache: cache.r6g.large = $175/month + 95% cache hit rate = $200 total vs $500 (60% savings). Additional benefits: reduced RDS instance size, improved response time (1ms cache vs 50ms database). Critical for: product catalogs, user profiles, reference data, API responses.",
      "category": "database",
      "architectural_patterns": [
        {
          "pattern_name": "Cache-Aside",
          "relationship": "missing_implementation",
          "description": "No caching layer between application and database for frequently accessed data"
        }
      ],
      "pattern_implementation_guidance": "Create ElastiCache Redis cluster (Multi-AZ for production), update application connection string, implement cache access pattern: GET from cache -> if miss -> GET from DB -> SET in cache with TTL, use consistent cache key format (service:entity:id), handle cache failures gracefully (fallback to DB), set CloudWatch alarms for cache hit rate <70%.",
      "output_notes": null,
      "notes": "AWS Database Caching Strategies - Cache-Aside Pattern",
      "references": [
        "https://docs.aws.amazon.com/whitepapers/latest/database-caching-strategies-using-redis/caching-patterns.html",
        "https://aws.amazon.com/caching/best-practices/",
        "https://docs.aws.amazon.com/AmazonElastiCache/latest/red-ug/Strategies.html"
      ],
      "metadata": {
        "created_at": "2025-11-06T20:44:23.794745+00:00",
        "updated_at": "2025-11-06T20:44:23.794745+00:00",
        "contributors": [
          "pattern-integration-2025"
        ],
        "source": "AWS Database Caching Strategies - Cache-Aside Pattern"
      },
      "tags": [
        "pattern:cache-aside",
        "performance-pattern",
        "elasticache",
        "database-optimization",
        "read-heavy-workload"
      ],
      "detection_methods": [
        {
          "method": "RDS Performance Insights",
          "details": "Top SQL queries showing identical SELECT statements with >1000 executions/minute"
        }
      ],
      "remediation_examples": [
        {
          "language": "python",
          "code": "import boto3\nimport json\nfrom redis import Redis\n\nredis_client = Redis(host='elasticache-endpoint', port=6379)\n\ndef get_user_profile(user_id):\n    cache_key = f'user:profile:{user_id}'\n    cached = redis_client.get(cache_key)\n    if cached:\n        return json.loads(cached)\n    \n    # Cache miss - query database\n    result = query_database(user_id)\n    redis_client.setex(cache_key, 300, json.dumps(result))  # 5-min TTL\n    return result",
          "description": "Python implementation of Cache-Aside with ElastiCache Redis and RDS"
        }
      ]
    }
  ]
}